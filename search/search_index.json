{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"voromesh","text":""},{"location":"#features","title":"Features","text":"<ul> <li>Creates meshes from a bounded Voronoi diagram of a 2D point cloud</li> <li>Extrude 2D surface meshes to 3D</li> <li>Export as VTU or MESH for TOUGH3</li> </ul>"},{"location":"#dokumentation","title":"Dokumentation","text":"<p>Voromesh was designed for setting up conceptual simulations models for carbon dioxide storage.  The documention including workflows can be found here.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<ol> <li>Clone the repro: <code>git clone https://github.com/jtecklenburg/voromesh.git</code></li> <li>Install with pip locally: Change to folder with setup.py and run <code>pip install -e .</code></li> </ol> <p>or</p> <ol> <li>Install with pip from Github: <code>pip install git+https://github.com/jtecklenburg/voromesh.git@main</code></li> </ol>"},{"location":"#notice","title":"Notice","text":"<p>This software was developed at Bundesanstalt f\u00fcr Geowissenschaften und Rohstoffe (BGR) in Hannover</p> <p>The project leading to this software has received funding from the European Union\u2019s Horizon 2020 research and innovation programme under grant agreement \"LEILAC2 - Low Emission Intensity Lime and Cement\" GA 884170. </p>"},{"location":"api_geo/","title":"API of module geo","text":""},{"location":"api_geo/#voromesh.geo.layersfromsurf","title":"<code>layersfromsurf(surfmesh, thickness)</code>","text":"<p>Use a topographic surface to create a 3D terrain-following mesh.</p>"},{"location":"api_geo/#voromesh.geo.layersfromsurf--parameters","title":"Parameters","text":"<p>surfmesh : Pyvista.UnstructuredGrid with 2D-Elements     Surface mesh. thickness : List of float     thickness of layers in z-direction.</p>"},{"location":"api_geo/#voromesh.geo.layersfromsurf--returns","title":"Returns","text":"<p>mesh : Pyvista.UnstructuredGrid with 3D-Elements     Extruded surface mesh.</p> Source code in <code>voromesh/geo/__init__.py</code> <pre><code>def layersfromsurf(surfmesh, thickness):\n    \"\"\"\n    Use a topographic surface to create a 3D terrain-following mesh.\n\n    Parameters\n    ----------\n    surfmesh : Pyvista.UnstructuredGrid with 2D-Elements\n        Surface mesh.\n    thickness : List of float\n        thickness of layers in z-direction.\n\n    Returns\n    -------\n    mesh : Pyvista.UnstructuredGrid with 3D-Elements\n        Extruded surface mesh.\n\n    \"\"\"\n\n    surfmesh = surfmesh.compute_cell_sizes(length=False,\n                                           area=True,\n                                           volume=False)\n    area = surfmesh[\"Area\"]\n    volume = list()\n\n    # Typ des Geometry bzws. des Prismas\n    ctype = {3: vtk.VTK_WEDGE,\n             4: vtk.VTK_HEXAHEDRON,\n             5: vtk.VTK_PENTAGONAL_PRISM,\n             6: vtk.VTK_HEXAGONAL_PRISM,\n             7: vtk.VTK_CONVEX_POINT_SET}\n\n    nlayer = np.size(thickness)\n    points = np.tile(surfmesh.points, (nlayer+1, 1))\n    nc = surfmesh.number_of_points\n\n    # F\u00fcr jede Schicht werden z-Koordinaten festgelegt.\n    for i in range(nlayer):\n        points[((i+1)*nc):(i+2)*nc, 2] = (points[i*nc:((i+1)*nc), 2]\n                                          + thickness[i])\n\n    cells = list()\n    celltypes = list()\n    layer = list()\n\n    ind = 0\n    for i in range(surfmesh.number_of_cells):\n        npoints = surfmesh.cells[ind]\n        edges = surfmesh.cells[ind+1:ind+1+npoints]\n\n        ind = ind + 1 + npoints\n\n        for j in range(nlayer):\n            celltypes.append(ctype.setdefault(npoints,\n                                              vtk.VTK_CONVEX_POINT_SET))\n\n            cells.append(2*npoints)         # number of points\n            cells.extend(edges+j*nc)        # lower side\n            cells.extend(edges+(j+1)*nc)    # upper side\n\n            volume.append(area[i]*thickness[j])\n            layer.append(j)\n\n    mesh = pv.UnstructuredGrid(cells,\n                               np.array(celltypes),\n                               points)\n\n    mesh[\"Volume\"] = volume\n    mesh[\"Layer\"] = layer\n\n    return mesh\n</code></pre>"},{"location":"api_geo/#voromesh.geo.update_z_from_surf","title":"<code>update_z_from_surf(mesh, surf)</code>","text":"<p>Maps elevation data from surf to mesh.</p>"},{"location":"api_geo/#voromesh.geo.update_z_from_surf--parameters","title":"Parameters","text":"<p>mesh : pyvista.UnstructuredGrid     (Surface) Mesh without elevation data. surf : pyvista.UnstructuredGrid     Surface mesh with elevation data.</p>"},{"location":"api_geo/#voromesh.geo.update_z_from_surf--returns","title":"Returns","text":"<p>mesh : pyvista.UnstructuredGrid     (Surface) Mesh with elevation data from surf</p> Source code in <code>voromesh/geo/__init__.py</code> <pre><code>def update_z_from_surf(mesh, surf):\n    \"\"\"\n    Maps elevation data from surf to mesh.\n\n    Parameters\n    ----------\n    mesh : pyvista.UnstructuredGrid\n        (Surface) Mesh without elevation data.\n    surf : pyvista.UnstructuredGrid\n        Surface mesh with elevation data.\n\n    Returns\n    -------\n    mesh : pyvista.UnstructuredGrid\n        (Surface) Mesh with elevation data from surf\n\n    \"\"\"\n\n    z = surf.points[:, 2].copy()\n    surf[\"z\"] = z\n    surf.points[:, 2] = 0\n\n    mesh = mesh.sample(surf)\n    mesh.points[:, 2] = mesh[\"z\"]\n\n    surf.points[:, 2] = z\n    return mesh\n</code></pre>"},{"location":"api_tough3/","title":"API of modul tough3","text":""},{"location":"api_tough3/#voromesh.tough3.outfile2vtu","title":"<code>outfile2vtu(path, mesh, outfile='OUTFILE', do_sort=True)</code>","text":"<p>Reads an OUTFILE from a TOUGH3 simulation and append simulation results to the vtu mesh for each timestamp in the OUTFILE. Also writes a pvd file to relate files and timestamps in Paraview.</p>"},{"location":"api_tough3/#voromesh.tough3.outfile2vtu--parameters","title":"Parameters","text":"<p>path : string     path to TOUGH3 OUTFILE mesh : string     name of vtu mesh in path outfile : string     name of outfile. Default = \"OUTFILE\". do_sort : boolean     parallel simulations may change the order of elements. For this     reason sorting may be a good idea. Default = True.</p>"},{"location":"api_tough3/#voromesh.tough3.outfile2vtu--returns","title":"Returns","text":"<p>None.</p> Source code in <code>voromesh/tough3/__init__.py</code> <pre><code>def outfile2vtu(path, mesh, outfile=\"OUTFILE\", do_sort=True):\n    \"\"\"\n    Reads an OUTFILE from a TOUGH3 simulation and append simulation results\n    to the vtu mesh for each timestamp in the OUTFILE. Also writes a pvd file\n    to relate files and timestamps in Paraview.\n\n    Parameters\n    ----------\n    path : string\n        path to TOUGH3 OUTFILE\n    mesh : string\n        name of vtu mesh in path\n    outfile : string\n        name of outfile. Default = \"OUTFILE\".\n    do_sort : boolean\n        parallel simulations may change the order of elements. For this\n        reason sorting may be a good idea. Default = True.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n\n    try:\n        path_outfile = os.path.join(path, outfile)\n        outputs = toughio.read_output(path_outfile)\n    except OSError:\n        print(\"Error reading OUTFILE: \" + path_outfile)\n        sys.exit()\n\n    try:\n        path_meshfile = os.path.join(path, mesh)\n        mesh = pv.read(path_meshfile)\n    except OSError:\n        print(\"Error reading mesh file: \" + path_meshfile)\n        sys.exit\n\n    pvdfile = os.path.join(path, \"outfile.pvd\")\n    pvd = pvdwriter(pvdfile)\n\n    # Parallel simulations may change the order of elements.\n    if do_sort:\n        nn = outputs[-1][3]\n        ind = np.argsort(nn)\n\n    i = 0\n\n    for output in outputs:\n        for key in output[4]:\n\n            if do_sort:\n                mesh[key] = output[4][key][ind]\n            else:\n                mesh[key] = output[4][key]\n\n\n        timestamp = output[2]/(365.25*24*60*60)\n        filename = \"mesh_\" + str(i) + \".vtu\"\n        print(filename + \" | \"+ str(timestamp))\n\n        pvd.append(filename, timestamp)\n\n        mesh.save(os.path.join(path, filename))\n        i = i + 1\n\n    pvd.close()\n    print(\"complete!\")\n</code></pre>"},{"location":"api_tough3/#voromesh.tough3.update_gener","title":"<code>update_gener(path2infile, mesh, materials, wells)</code>","text":"<p>Update the well information in the TOUGH3 INFILE</p>"},{"location":"api_tough3/#voromesh.tough3.update_gener--parameters","title":"Parameters","text":"<p>path2infile : string     path to TOUGH3 INFILE. mesh : pyvista.UnstructuredGrid with cell data     see write_mesh function. materials : dict     see write_mesh function. wells : dict     Define inflow and outflows.     Key of dict is the material. The flow is splitted according to the     volume fraction, when more than one cell has the same material.     Value of dict is a dict with flow components. See TOUGH3 manual and     TOUGH3 EOS manuals for details.     Example: wells = {\"WELL\": {\"COM1\": 28.53, \"COM3\": 1e-6}}</p>"},{"location":"api_tough3/#voromesh.tough3.update_gener--returns","title":"Returns","text":"<p>None.</p> Source code in <code>voromesh/tough3/__init__.py</code> <pre><code>def update_gener(path2infile, mesh, materials, wells):\n    \"\"\"\n    Update the well information in the TOUGH3 INFILE\n\n    Parameters\n    ----------\n    path2infile : string\n        path to TOUGH3 INFILE.\n    mesh : pyvista.UnstructuredGrid with cell data\n        see write_mesh function.\n    materials : dict\n        see write_mesh function.\n    wells : dict\n        Define inflow and outflows.\n        Key of dict is the material. The flow is splitted according to the\n        volume fraction, when more than one cell has the same material.\n        Value of dict is a dict with flow components. See TOUGH3 manual and\n        TOUGH3 EOS manuals for details.\n        Example: wells = {\"WELL\": {\"COM1\": 28.53, \"COM3\": 1e-6}}\n\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n\n    material = [materials[i] for i in mesh[\"material\"]]\n    volume = mesh[\"Volume\"]\n\n    _update_gener(material, volume, wells, path2infile,\n                  names=False, verbose=False)\n</code></pre>"},{"location":"api_tough3/#voromesh.tough3.write_mesh","title":"<code>write_mesh(path, mesh, materials)</code>","text":"<p>Writes a mesh in TOUGH2/TOUGH3 format.</p>"},{"location":"api_tough3/#voromesh.tough3.write_mesh--parameters","title":"Parameters","text":"<p>path : string     Path for writing the TOUGH3 mesh. mesh : pyvista.UnstructuredGrid with cell data (see below)     mesh[\"Volume\"] :  cell volumes     mesh[\"material\"] : cell material as integer     mesh[\"initial_condition\"] : cell initial conditions as list                                 find more information in TOUGH EOS manuals materials : dict     Relate numbers in mesh[\"material\"] to material names from the TOUGH     INFILE. Example: materials = {1: \"WELL\", 2: \"SAND\"}</p>"},{"location":"api_tough3/#voromesh.tough3.write_mesh--returns","title":"Returns","text":"<p>None.</p> Source code in <code>voromesh/tough3/__init__.py</code> <pre><code>def write_mesh(path, mesh, materials):\n    \"\"\"\n    Writes a mesh in TOUGH2/TOUGH3 format.\n\n    Parameters\n    ----------\n    path : string\n        Path for writing the TOUGH3 mesh.\n    mesh : pyvista.UnstructuredGrid with cell data (see below)\n        mesh[\"Volume\"] :  cell volumes\n        mesh[\"material\"] : cell material as integer\n        mesh[\"initial_condition\"] : cell initial conditions as list\n                                    find more information in TOUGH EOS manuals\n    materials : dict\n        Relate numbers in mesh[\"material\"] to material names from the TOUGH\n        INFILE. Example: materials = {1: \"WELL\", 2: \"SAND\"}\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    dist, areai, areao, betax_ = calc_conne(mesh)\n\n    volume = mesh[\"Volume\"]                             # 1\n    material = [materials[i] for i in mesh[\"material\"]]  # 2\n\n    area = np.zeros(np.size(volume))\n    for key in areao:\n        area[key] = areao[key]                          # 3\n\n    centers = mesh.cell_centers().points                # 4\n\n    ne = list(areai.keys())                             # 5\n\n    d1 = 0.5 * np.fromiter(dist.values(), dtype=float)  # 7\n    d2 = d1                                             # 8\n\n    areax = np.fromiter(areai.values(), dtype=float)    # 9\n\n    betax = np.fromiter(betax_.values(), dtype=float)   # 10\n\n    incon = mesh[\"initial_condition\"]                   # 11\n\n    # Nur Unterschiede in h (1,2 -&gt; 1) und v (3)\n    isot = np.ones(np.size(areax))                      # 6\n    ind = np.abs(betax) &gt; 0.5\n    isot[ind] = 3\n\n    _write_mesh(path, volume, material, area, centers,\n                ne, isot, d1, d2, areax, betax, incon)\n</code></pre>"},{"location":"api_voronoi/","title":"API of class Voronoi","text":"Source code in <code>voromesh/voronoi/__init__.py</code> <pre><code>class Voronoi:\n    def __init__(self, points, buffer_size=1, boundary=None):\n        \"\"\"\n        Bounded 2D Voronoi decomposition for given points.\n        The boundary is either calculated from the buffered convex hull of the\n        given points with the given buffer_size (default) or passed directly.\n\n        Parameters\n        ----------\n        points : numpy.array of shape (npoints, ndim=2)\n            Coordinates of points to construct a Voronoi diagram from.\n        buffer_size : float, Optional\n            Buffer for convex hull &gt;= 0.\n        boundary : shapely.geometry.polygon.Polygon, Optional\n            Boundary for Voronoi decomposition.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n\n        n = shape(points)\n\n        if not n[1] == 2:\n            raise TypeError(\"Points needs to be an array of shape Nx2, but is \"\n                            + str(n[0]) + \"x\" + str(n[1]) + \"!\")\n\n        if buffer_size &lt; 0:\n            raise ValueError(\"Buffer_size needs to be &gt;= 0!\")\n\n        if boundary is None:\n            self.buffer_size = buffer_size\n            boundary = convex_hull(points, buffer_size)\n        elif type(boundary) is Polygon:\n            self.buffer_size = None\n        else:\n            self.buffer_size = None\n            raise Warning(\"Boundary is not of type\"\n                          + \"shapely.geometry.polygon.Polygon.\\n\"\n                          + \"This can lead to unexpected results!\")\n\n        self.voronoi, self.points = voronoi_bound(points, boundary)\n\n    def plot(self, center=False, tri=False):\n        \"\"\"\n        plots the Voronoi diagramm.\n\n        Parameters\n        ----------\n        center : Bool, optional\n            Add center points to plot. The default is False.\n        tri : Bool, optional\n            Add Dilaunay triangulation to plot. The default is False.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        if tri:\n            tri = Delaunay(self.points)\n            plt.triplot(self.points[:, 0], self.points[:, 1], tri.simplices)\n\n        if center:\n            plt.plot(self.points[:, 0], self.points[:, 1], 'o')\n\n        for r in self.voronoi.geoms:\n            plt.fill(*zip(*array(list(\n                zip(r.boundary.coords.xy[0][:-1],\n                    r.boundary.coords.xy[1][:-1])))),\n                alpha=0.4)\n\n        plt.axis('equal')\n        plt.show()\n\n    def to_vtk(self, decimalplace=8, dim=\"Z\"):\n        \"\"\"\n        Converts the Voronoi diagram to a vtk unstructured grid.\n\n        Parameters\n        ----------\n        decimalplace : int, optional\n            _description_. Defaults to 8.\n        dim : str, optional\n            _description_. Defaults to \"Z\".\n\n        Returns:\n            vtkUnstructuredGrid: VTK unstructured grid\n        \"\"\"\n\n        return to_vtk(self.voronoi, decimalplace, dim)\n\n    def to_pyvista(self, decimalplace=8, dim=\"Z\"):\n        \"\"\"\n        Converts the Voronoi diagram to a pyvista unstructured grid.\n\n        Returns\n        -------\n            pyvista.UnstructuredGrid: Pyvista unstructured grid\n\n        \"\"\"\n        return to_pyvista(self.voronoi, decimalplace, dim)\n</code></pre>"},{"location":"api_voronoi/#voromesh.Voronoi.__init__","title":"<code>__init__(points, buffer_size=1, boundary=None)</code>","text":"<p>Bounded 2D Voronoi decomposition for given points. The boundary is either calculated from the buffered convex hull of the given points with the given buffer_size (default) or passed directly.</p>"},{"location":"api_voronoi/#voromesh.Voronoi.__init__--parameters","title":"Parameters","text":"<p>points : numpy.array of shape (npoints, ndim=2)     Coordinates of points to construct a Voronoi diagram from. buffer_size : float, Optional     Buffer for convex hull &gt;= 0. boundary : shapely.geometry.polygon.Polygon, Optional     Boundary for Voronoi decomposition.</p>"},{"location":"api_voronoi/#voromesh.Voronoi.__init__--returns","title":"Returns","text":"<p>None.</p> Source code in <code>voromesh/voronoi/__init__.py</code> <pre><code>def __init__(self, points, buffer_size=1, boundary=None):\n    \"\"\"\n    Bounded 2D Voronoi decomposition for given points.\n    The boundary is either calculated from the buffered convex hull of the\n    given points with the given buffer_size (default) or passed directly.\n\n    Parameters\n    ----------\n    points : numpy.array of shape (npoints, ndim=2)\n        Coordinates of points to construct a Voronoi diagram from.\n    buffer_size : float, Optional\n        Buffer for convex hull &gt;= 0.\n    boundary : shapely.geometry.polygon.Polygon, Optional\n        Boundary for Voronoi decomposition.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n\n    n = shape(points)\n\n    if not n[1] == 2:\n        raise TypeError(\"Points needs to be an array of shape Nx2, but is \"\n                        + str(n[0]) + \"x\" + str(n[1]) + \"!\")\n\n    if buffer_size &lt; 0:\n        raise ValueError(\"Buffer_size needs to be &gt;= 0!\")\n\n    if boundary is None:\n        self.buffer_size = buffer_size\n        boundary = convex_hull(points, buffer_size)\n    elif type(boundary) is Polygon:\n        self.buffer_size = None\n    else:\n        self.buffer_size = None\n        raise Warning(\"Boundary is not of type\"\n                      + \"shapely.geometry.polygon.Polygon.\\n\"\n                      + \"This can lead to unexpected results!\")\n\n    self.voronoi, self.points = voronoi_bound(points, boundary)\n</code></pre>"},{"location":"api_voronoi/#voromesh.Voronoi.plot","title":"<code>plot(center=False, tri=False)</code>","text":"<p>plots the Voronoi diagramm.</p>"},{"location":"api_voronoi/#voromesh.Voronoi.plot--parameters","title":"Parameters","text":"<p>center : Bool, optional     Add center points to plot. The default is False. tri : Bool, optional     Add Dilaunay triangulation to plot. The default is False.</p>"},{"location":"api_voronoi/#voromesh.Voronoi.plot--returns","title":"Returns","text":"<p>None.</p> Source code in <code>voromesh/voronoi/__init__.py</code> <pre><code>def plot(self, center=False, tri=False):\n    \"\"\"\n    plots the Voronoi diagramm.\n\n    Parameters\n    ----------\n    center : Bool, optional\n        Add center points to plot. The default is False.\n    tri : Bool, optional\n        Add Dilaunay triangulation to plot. The default is False.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    if tri:\n        tri = Delaunay(self.points)\n        plt.triplot(self.points[:, 0], self.points[:, 1], tri.simplices)\n\n    if center:\n        plt.plot(self.points[:, 0], self.points[:, 1], 'o')\n\n    for r in self.voronoi.geoms:\n        plt.fill(*zip(*array(list(\n            zip(r.boundary.coords.xy[0][:-1],\n                r.boundary.coords.xy[1][:-1])))),\n            alpha=0.4)\n\n    plt.axis('equal')\n    plt.show()\n</code></pre>"},{"location":"api_voronoi/#voromesh.Voronoi.to_pyvista","title":"<code>to_pyvista(decimalplace=8, dim='Z')</code>","text":"<p>Converts the Voronoi diagram to a pyvista unstructured grid.</p>"},{"location":"api_voronoi/#voromesh.Voronoi.to_pyvista--returns","title":"Returns","text":"<pre><code>pyvista.UnstructuredGrid: Pyvista unstructured grid\n</code></pre> Source code in <code>voromesh/voronoi/__init__.py</code> <pre><code>def to_pyvista(self, decimalplace=8, dim=\"Z\"):\n    \"\"\"\n    Converts the Voronoi diagram to a pyvista unstructured grid.\n\n    Returns\n    -------\n        pyvista.UnstructuredGrid: Pyvista unstructured grid\n\n    \"\"\"\n    return to_pyvista(self.voronoi, decimalplace, dim)\n</code></pre>"},{"location":"api_voronoi/#voromesh.Voronoi.to_vtk","title":"<code>to_vtk(decimalplace=8, dim='Z')</code>","text":"<p>Converts the Voronoi diagram to a vtk unstructured grid.</p>"},{"location":"api_voronoi/#voromesh.Voronoi.to_vtk--parameters","title":"Parameters","text":"<p>decimalplace : int, optional     description. Defaults to 8. dim : str, optional     description. Defaults to \"Z\".</p> <p>Returns:</p> Name Type Description <code>vtkUnstructuredGrid</code> <p>VTK unstructured grid</p> Source code in <code>voromesh/voronoi/__init__.py</code> <pre><code>def to_vtk(self, decimalplace=8, dim=\"Z\"):\n    \"\"\"\n    Converts the Voronoi diagram to a vtk unstructured grid.\n\n    Parameters\n    ----------\n    decimalplace : int, optional\n        _description_. Defaults to 8.\n    dim : str, optional\n        _description_. Defaults to \"Z\".\n\n    Returns:\n        vtkUnstructuredGrid: VTK unstructured grid\n    \"\"\"\n\n    return to_vtk(self.voronoi, decimalplace, dim)\n</code></pre>"},{"location":"helloworld/","title":"Bounded Voronoi diagram from 2D points","text":"In\u00a0[1]: Copied! <pre>%matplotlib inline\n\nfrom voromesh import Voronoi\nfrom numpy import array\n\npoints = array([[-0.5, -0.5], [0.5, -0.5],\n                [-0.5, 0.5], [0.5, 0.5],\n                [0.0, 0.0]])\n\nvoro = Voronoi(points, buffer_size=0.4)\n\nvoro.plot(center=True, tri=True)\n</pre> %matplotlib inline  from voromesh import Voronoi from numpy import array  points = array([[-0.5, -0.5], [0.5, -0.5],                 [-0.5, 0.5], [0.5, 0.5],                 [0.0, 0.0]])  voro = Voronoi(points, buffer_size=0.4)  voro.plot(center=True, tri=True) <pre>Matplotlib is building the font cache; this may take a moment.\n</pre> <p>As next step we export the Voronoi diagramm as Pyvista unstructured grid for further usage.</p> In\u00a0[2]: Copied! <pre>import pyvista as pv\n\nmesh = voro.to_pyvista()\n\n# Plot the grid in notebook\npv.set_jupyter_backend('static')\nmesh.plot(notebook=True, show_edges=True)\n\n# mesh.save(\"voronoi.vtu\")\n</pre> import pyvista as pv  mesh = voro.to_pyvista()  # Plot the grid in notebook pv.set_jupyter_backend('static') mesh.plot(notebook=True, show_edges=True)  # mesh.save(\"voronoi.vtu\")"},{"location":"helloworld/#bounded-voronoi-diagram-from-2d-points","title":"Bounded Voronoi diagram from 2D points\u00b6","text":"<p>Let us create some points and compute the Voronoi diagram (aka Thiessen polygons or Dirichlet tesselation). The Voronoi diagram is bounded by the buffered convex hull of the given points. The buffer size needs to be specified.</p> <p>Then we can plot the Voronoi diagram. Optional we can display the points respectively the center of Voronoi cells and the triangulation of the points.</p>"},{"location":"mesh1/","title":"Creating a Voronoi mesh from a GMSH mesh","text":"In\u00a0[1]: Copied! <pre>import meshio\nmesh = meshio.read(\"./mesh/circle.msh\")\npoints = mesh.points\n\npoints\n</pre> import meshio mesh = meshio.read(\"./mesh/circle.msh\") points = mesh.points  points <pre>\n</pre> Out[1]: <pre>array([[1000.        ,    0.        ,    0.        ],\n       [ 997.13604528,   75.62874588,    0.        ],\n       [ 988.56058559,  150.82429716,    0.        ],\n       ...,\n       [ 109.65476416,  128.54861141,    0.        ],\n       [ 370.80378341,  447.01151374,    0.        ],\n       [ -62.24480108,  -51.78637557,    0.        ]])</pre> <p>We use the points from this mesh to create the Voronoi mesh. Because <code>Voronoi()</code> create a 2D Voronoi decomposition only, we need to pass an array with two dimensions.</p> In\u00a0[2]: Copied! <pre>from voromesh import Voronoi\nvoro = Voronoi(points[:, :2], buffer_size=40.0)\nmesh = voro.to_pyvista()\nmesh.save(\"./mesh/circle.vtu\")\n</pre> from voromesh import Voronoi voro = Voronoi(points[:, :2], buffer_size=40.0) mesh = voro.to_pyvista() mesh.save(\"./mesh/circle.vtu\") <p>The mesh can be plotted with Pyvista.</p> In\u00a0[3]: Copied! <pre># Plot the grid in notebook\nimport pyvista as pv\npv.set_jupyter_backend('static')\nmesh.plot(notebook=True, show_edges=True)\n</pre> # Plot the grid in notebook import pyvista as pv pv.set_jupyter_backend('static') mesh.plot(notebook=True, show_edges=True)"},{"location":"mesh1/#creating-a-voronoi-mesh-from-a-gmsh-mesh","title":"Creating a Voronoi mesh from a GMSH mesh\u00b6","text":"<p>First we need to create a mesh. Here we use Gmsh and create a triangular mesh with a local grid refinement using the Frontal-Delauney-Algorithm.</p> <pre><code>// Geometry\nSetFactory(\"OpenCASCADE\");\nCircle(1) = {0.0,0.0,0.0,1000.0,0.0,2*Pi};\nCurve Loop(1) = {1};\nPlane Surface(1) = {1};\n\n// Mesh refinement\nField[1] = MathEval;\nField[1].F = \"0.3*(Sqrt(x^2 + y^2))^0.8+1.0\";\nBackground Field = 1;\n\n// Options\nMesh.CharacteristicLengthFromPoints = 0;\nMesh.CharacteristicLengthExtendFromBoundary = 0;\nMesh.MeshSizeFromCurvature = 0;\nMesh.Algorithm = 6;</code></pre> <p>After meshing, we can save the mesh to a file. Now we can switch to Python and read the mesh with meshio</p>"},{"location":"mesh2/","title":"Mapping elevation data to a Voronoi mesh","text":"In\u00a0[1]: Copied! <pre>import pyvista as pv\nfrom pyvista import examples\n\ndem = examples.download_crater_topo()\nsurf = dem.extract_subset((500, 900, 400, 800, 0, 0), (5, 5, 1))\nsurf = surf.warp_by_scalar()\n\npv.set_jupyter_backend('static')\nsurf.plot(notebook=True, show_edges=False)\n\nsurf_center = surf.center\nsurf_center\n</pre> import pyvista as pv from pyvista import examples  dem = examples.download_crater_topo() surf = dem.extract_subset((500, 900, 400, 800, 0, 0), (5, 5, 1)) surf = surf.warp_by_scalar()  pv.set_jupyter_backend('static') surf.plot(notebook=True, show_edges=False)  surf_center = surf.center surf_center Out[1]: <pre>[1820500.0, 5649000.0, 2105.2999877929688]</pre> <p>We read the mesh from the last example. Because the centers of the example data and the mesh did not match, we shift the center of the mesh to the center of the example data.</p> <p>Then we use <code>update_z_from_surf()</code> to map the elevation data from the example data to the mesh.</p> In\u00a0[2]: Copied! <pre>mesh = pv.read(\"./mesh/circle.vtu\")\n\nmesh.points\n\nmesh.points[:, 0] = mesh.points[:, 0] + surf_center[0]\nmesh.points[:, 1] = mesh.points[:, 1] + surf_center[1]\n\nfrom voromesh import geo\nsurfmesh = geo.update_z_from_surf(mesh, surf)\nsurfmesh.plot(notebook=True, show_edges=True)\n</pre> mesh = pv.read(\"./mesh/circle.vtu\")  mesh.points  mesh.points[:, 0] = mesh.points[:, 0] + surf_center[0] mesh.points[:, 1] = mesh.points[:, 1] + surf_center[1]  from voromesh import geo surfmesh = geo.update_z_from_surf(mesh, surf) surfmesh.plot(notebook=True, show_edges=True)  <p>Now we can add some layers to get a volume mesh.</p> <p>Remark: For ploting VTK divides prisms with more than six sides (Heptagonal prisms, octagonal prisms, ...) into tetrahedrons.</p> In\u00a0[3]: Copied! <pre>thickness = [10, 20, 30, 40]\n\nvolmesh = geo.layersfromsurf(surfmesh, thickness)\nvolmesh.plot(notebook=True, show_edges=True)\n\n# volmesh.save(\"./mesh/volmesh.vtu\")\n</pre> thickness = [10, 20, 30, 40]  volmesh = geo.layersfromsurf(surfmesh, thickness) volmesh.plot(notebook=True, show_edges=True)  # volmesh.save(\"./mesh/volmesh.vtu\")"},{"location":"mesh2/#mapping-elevation-data-to-a-voronoi-mesh","title":"Mapping elevation data to a Voronoi mesh\u00b6","text":"<p>Now we want to map elevation data to the mesh, we created in the last example. To do this, we first need some elevation data. For demonstration purpose, we use some example data from pyvista.</p>"},{"location":"structured/","title":"Extrusion of a surface mesh","text":"In\u00a0[1]: Copied! <pre>import pyvista as pv\nfrom pyvista import examples\n\ndem = examples.download_crater_topo()\nsurfmesh = dem.extract_subset((500, 900, 400, 800, 0, 0), (5, 5, 1))\nsurfmesh = surfmesh.warp_by_scalar()\n\npv.set_jupyter_backend('static')\nsurfmesh.plot(notebook=True, show_edges=True)\n</pre> import pyvista as pv from pyvista import examples  dem = examples.download_crater_topo() surfmesh = dem.extract_subset((500, 900, 400, 800, 0, 0), (5, 5, 1)) surfmesh = surfmesh.warp_by_scalar()  pv.set_jupyter_backend('static') surfmesh.plot(notebook=True, show_edges=True) <p>Now we define the thickness of the layers for extruding this surface mesh. Because the type of the example data is a structured grid and <code>layersfromsurf()</code> requires an unstructured grid, we first cast the type of the surface mesh to an unstructured grid. Finally we can extrude the surface mesh to a volume mesh.</p> <p>This example is quoted from this example in Pyvista, but <code>layersfromsurf()</code> is a one-liner and works for meshes consisting of quads, triangles and polygons.</p> In\u00a0[2]: Copied! <pre>from voromesh import geo\nimport numpy as np\n\nthickness = np.array([25] * 5 + [35] * 3 + [50] * 2 + [75, 100])\n\nvolmesh = geo.layersfromsurf(surfmesh.cast_to_unstructured_grid(), thickness)\n\ncpos = [\n    (1826736.796308761, 5655837.275274233, 4676.8405505181745),\n    (1821066.1790519988, 5649248.765538796, 943.0995128226014),\n    (-0.2797856225380979, -0.27966946337594883, 0.9184252809434081),\n]\n\nvolmesh.plot(notebook=True, show_edges=True, lighting=False, cpos=cpos)\n</pre> from voromesh import geo import numpy as np  thickness = np.array([25] * 5 + [35] * 3 + [50] * 2 + [75, 100])  volmesh = geo.layersfromsurf(surfmesh.cast_to_unstructured_grid(), thickness)  cpos = [     (1826736.796308761, 5655837.275274233, 4676.8405505181745),     (1821066.1790519988, 5649248.765538796, 943.0995128226014),     (-0.2797856225380979, -0.27966946337594883, 0.9184252809434081), ]  volmesh.plot(notebook=True, show_edges=True, lighting=False, cpos=cpos)"},{"location":"structured/#extrusion-of-a-surface-mesh","title":"Extrusion of a surface mesh\u00b6","text":"<p>Let us load some example data.</p>"},{"location":"tough1/","title":"2D mesh for TOUGH (Part 1)","text":"In\u00a0[1]: Copied! <pre>import xymesh\nimport matplotlib.pyplot as plt\n\npoints = xymesh.xymesh()\n\nplt.plot(points[:,0], points[:, 1], '.')\nplt.axis(\"equal\")\nplt.show()\n</pre> import xymesh import matplotlib.pyplot as plt  points = xymesh.xymesh()  plt.plot(points[:,0], points[:, 1], '.') plt.axis(\"equal\") plt.show() <p>Here we cannot see any points. For this reason, we zoom a little bit.</p> In\u00a0[2]: Copied! <pre>plt.plot(points[:,0], points[:, 1], '.')\n#\nplt.axis('equal')\nplt.xlim(-6000, -5900)\nplt.ylim(-500, -400)\nplt.show()\n</pre> plt.plot(points[:,0], points[:, 1], '.') # plt.axis('equal') plt.xlim(-6000, -5900) plt.ylim(-500, -400) plt.show() <p>When we look at the general view, we can see that the convex hull is a bad approximation for the boundary of this shape. For this reason, we need to think of something else.</p> <p>Here we triangulate the points. When look at a measure for the shape of the triangles, we can easily identify acute and very acute triangles. When we look at the triangles in detail, we can see, that the acute triangles are inside our shape and the very acute triangles are outside our shape. Now the next step is to define a limit to get rid of the very acute triangles. This limit can be found by looking at the histogram.</p> In\u00a0[3]: Copied! <pre>from shapely import MultiPoint\nfrom shapely.ops import triangulate, unary_union\n\ntri = triangulate(MultiPoint(points))\n\nparam = [region.area/(region.length**2) for region in tri]\nplt.hist(param)\nplt.show()\n</pre> from shapely import MultiPoint from shapely.ops import triangulate, unary_union  tri = triangulate(MultiPoint(points))  param = [region.area/(region.length**2) for region in tri] plt.hist(param) plt.show() <p>We select the limit somewhere between the two distributions.</p> <p>Then we remove all triangles smaller than the given limit and merge the remaining triangles into a single polygon. This polygon is buffered with a circle with a diameter of 1.0, because the mesh size in z-direction is 2.0. The resulting polygon is the boundary for the Voronoi decompostion.</p> In\u00a0[4]: Copied! <pre>limit = 0.005\n\ntri = [region for region in tri if region.area/(region.length**2) &gt; limit]\n\nboundary = unary_union(tri).buffer(1)\n</pre> limit = 0.005  tri = [region for region in tri if region.area/(region.length**2) &gt; limit]  boundary = unary_union(tri).buffer(1) <p>Now we can create the Voronoi mesh using the points and the boundary from above. We use <code>layersfromsurf()</code> to make the mesh 3D.</p> <p>When we convert the mesh to pyvista, the mesh is a xy-mesh. But we want to have a xz-mesh. For this reason, we switch dimensions.</p> In\u00a0[5]: Copied! <pre>from voromesh import Voronoi\nfrom voromesh.geo import layersfromsurf\n\nvoro = Voronoi(points, boundary=boundary)\nmesh = voro.to_pyvista()\n\n# Make mesh 3D and make xz\nmesh = layersfromsurf(mesh, [1])\nmesh.points[:, [1, 2]] = mesh.points[:, [2, 1]]\n\nmesh.save(\"./mesh/cos_.vtu\")\n</pre> from voromesh import Voronoi from voromesh.geo import layersfromsurf  voro = Voronoi(points, boundary=boundary) mesh = voro.to_pyvista()  # Make mesh 3D and make xz mesh = layersfromsurf(mesh, [1]) mesh.points[:, [1, 2]] = mesh.points[:, [2, 1]]  mesh.save(\"./mesh/cos_.vtu\") <p>Finally the mesh is prepared and we can have a look. It is not very comfortable to view this mesh in a Jupyter notebook. It is better to save the mesh to a file and look at the mesh with Paraview.</p> In\u00a0[6]: Copied! <pre>import pyvista as pv\n\npv.set_jupyter_backend('static')\n\ncpos = [\n    (-2.6839675192310253, -351.165133741359, 530.2535661651707),\n    (-2.6839675192310253, 0.5, 530.2535661651707),\n    (0.0, 0.0, 1.0),\n]\n\nmesh.plot(notebook=True, show_edges=True, cpos=cpos)\n</pre> import pyvista as pv  pv.set_jupyter_backend('static')  cpos = [     (-2.6839675192310253, -351.165133741359, 530.2535661651707),     (-2.6839675192310253, 0.5, 530.2535661651707),     (0.0, 0.0, 1.0), ]  mesh.plot(notebook=True, show_edges=True, cpos=cpos)"},{"location":"tough1/#2d-mesh-for-tough-part-1","title":"2D mesh for TOUGH (Part 1)\u00b6","text":"<p>In this example we want to create a mesh for the simulation of CO2-injection into the subsurface with TOUGH3. For the domain we assume a layer of sandstone with some thickness and some topology. Also, we assume that the flow processes in z-direction are faster than the flow processes in x-direction. For this reason we choose small cell sizes in z-direction and larger cell sizes in x-direction.</p> <p>We calculate the points resulting in a rectangular mesh with <code>xymesh()</code> (See code for details)</p>"},{"location":"tough2/","title":"Mesh properties for TOUGH3 (Part 2)","text":"In\u00a0[1]: Copied! <pre>import pyvista as pv\nimport numpy as np\n\nmesh = pv.read(\"./mesh/cos_.vtu\")\n\ncpos = [\n    (6.18603515625, -23302.265175994733 , 42.33445739746094),\n    (6.18603515625, 0.5, 42.33445739746094),\n    (0.0, 0.0, 1.0),\n]\n\npv.set_jupyter_backend('static')\nmesh.plot(notebook=True, show_edges=False, cpos=cpos)\n</pre> import pyvista as pv import numpy as np  mesh = pv.read(\"./mesh/cos_.vtu\")  cpos = [     (6.18603515625, -23302.265175994733 , 42.33445739746094),     (6.18603515625, 0.5, 42.33445739746094),     (0.0, 0.0, 1.0), ]  pv.set_jupyter_backend('static') mesh.plot(notebook=True, show_edges=False, cpos=cpos) <p>In order to set up a TOUGH simulation with this mesh, we need to supply further information: The initial condition, boundary conditions, materials as well as sinks and/or sources in the domain. For the initial condition and the materials we need to add cell data named \"initial_conditions\" and \"material\" to the mesh. Sinks and/or source require a dictionary (see below) and boundary conditions can be defined by changing the cell volumes or by defining material properties for the boundary cells.</p> <p>Remark: We also need an INPUT file to set up a simulation. We do not discuss INPUT files here! INPUT files can be created manually (not recommended!) or toughio or with toughio-dash.</p> <p>Note, that the cell data \"Volume\" is calculated from <code>Voronoi()</code> and is used to define the TOUGH3 mesh. Changes in the <code>mesh[\"Volume\"]</code> effects the cell volumes in the TOUGH3 mesh!</p> <p>First we define initial conditions. For our model (TOUGH3 ECO2N) we need to define the inital salt saturation, the initial CO2 saturation as well as the initial reservoir pressure and the temperature. The required parameters and the order of the parameters are specified in the TOUGH3 manual for the selected module.</p> In\u00a0[2]: Copied! <pre>density = 1050.0\ngravity = 9.81\n\nSSalt = 0.05\nSCO2 = 0.0\np0 = 29430000\nT0 = 83\n\ncenters = mesh.cell_centers().points\nincon = np.full((mesh.n_cells, 4), -1.0e9)\nincon[:, 0] = p0 - density * gravity * centers[:, 2]\nincon[:, 1] = SSalt\nincon[:, 2] = SCO2\nincon[:, 3] = T0\nmesh.cell_data[\"initial_condition\"] = incon\n</pre> density = 1050.0 gravity = 9.81  SSalt = 0.05 SCO2 = 0.0 p0 = 29430000 T0 = 83  centers = mesh.cell_centers().points incon = np.full((mesh.n_cells, 4), -1.0e9) incon[:, 0] = p0 - density * gravity * centers[:, 2] incon[:, 1] = SSalt incon[:, 2] = SCO2 incon[:, 3] = T0 mesh.cell_data[\"initial_condition\"] = incon <p>Now we define the boundary conditions. We want to have Dirichlet boundaries. To enforce that the initial conditions in the boundary cells did not change over time, we assign a large volume to the boundary cells.</p> In\u00a0[3]: Copied! <pre># Define Boundary conditions\nminx = -6000+20\nmaxx = 6000-20\nind = np.logical_or(centers[:,0] &lt; minx,\n                    centers[:,0] &gt; maxx)\nmesh[\"Volume\"][ind] = mesh[\"Volume\"][ind]*1000\n</pre> # Define Boundary conditions minx = -6000+20 maxx = 6000-20 ind = np.logical_or(centers[:,0] &lt; minx,                     centers[:,0] &gt; maxx) mesh[\"Volume\"][ind] = mesh[\"Volume\"][ind]*1000 <p>Next, we define the materials for the reservoir. We assume homogeneous rock and define two types of materials respectivly regions: \"SAND\" and \"WELL\".</p> <p>For the \"WELL\" region, we define an injection well. \"COM3\" is CO2 and 0.06 the injection rate. \"COM1\" is water. We need to inject a small ammount of water to support numerical stability.</p> In\u00a0[4]: Copied! <pre># Add materials\nmaterials = {1: \"SAND\",\n             2: \"WELL\"}\n\nmesh.cell_data[\"material\"] = 1\nind = mesh.find_cells_along_line([-3000, 0.5, -500], [-1500, 0.5, 500])\nmesh.cell_data[\"material\"][ind] = 2\n\n# Define Sources\nwells = {\"WELL\": {\"COM3\": 0.06,\n                  \"COM1\": 1e-6}}\n</pre> # Add materials materials = {1: \"SAND\",              2: \"WELL\"}  mesh.cell_data[\"material\"] = 1 ind = mesh.find_cells_along_line([-3000, 0.5, -500], [-1500, 0.5, 500]) mesh.cell_data[\"material\"][ind] = 2  # Define Sources wells = {\"WELL\": {\"COM3\": 0.06,                   \"COM1\": 1e-6}} <p>Now we have all information, we need write the MESH file and update the INFILE with the information on the wells. The injection rate is automatically distributed to all cells of the material \tproportional to the cell volumes.</p> <p>We also save the mesh as VTU. After the simulation, the results can be attached to the VTU file and analyzed with Paraview.</p> In\u00a0[5]: Copied! <pre>from voromesh.tough3 import write_mesh, update_gener\nfrom os.path import join\n\nmesh.save(\".\\mesh\\mesh_.vtu\")\n\n# Write TOUGH3 MESH file\npath = r\"./mesh/\"\nwrite_mesh(path, mesh, materials)\n\n# Update TOUGH3 INFILE with information on wells\nupdate_gener(join(path, \"INFILE\"), mesh, materials, wells)\n</pre> from voromesh.tough3 import write_mesh, update_gener from os.path import join  mesh.save(\".\\mesh\\mesh_.vtu\")  # Write TOUGH3 MESH file path = r\"./mesh/\" write_mesh(path, mesh, materials)  # Update TOUGH3 INFILE with information on wells update_gener(join(path, \"INFILE\"), mesh, materials, wells) <pre>\r0%\r\r1%\r\r2%\r\r3%\r</pre> <pre>\r4%\r\r5%\r\r6%\r\r7%\r</pre> <pre>\r8%\r\r9%\r\r10%\r\r11%\r\r12%\r</pre> <pre>\r13%\r\r14%\r\r15%\r\r16%\r\r17%\r</pre> <pre>\r18%\r\r19%\r\r20%\r\r21%\r\r22%\r</pre> <pre>\r23%\r\r24%\r\r25%\r\r26%\r\r27%\r</pre> <pre>\r28%\r\r29%\r\r30%\r\r31%\r\r32%\r</pre> <pre>\r33%\r\r34%\r\r35%\r\r36%\r\r37%\r</pre> <pre>\r38%\r\r39%\r\r40%\r\r41%\r\r42%\r</pre> <pre>\r43%\r\r44%\r\r45%\r\r46%\r\r47%\r</pre> <pre>\r48%\r\r49%\r\r50%\r\r51%\r\r52%\r</pre> <pre>\r53%\r\r54%\r\r55%\r\r56%\r\r57%\r</pre> <pre>\r58%\r\r59%\r\r60%\r\r61%\r\r62%\r</pre> <pre>\r63%\r\r64%\r\r65%\r\r66%\r\r67%\r</pre> <pre>\r68%\r\r69%\r\r70%\r\r71%\r\r72%\r</pre> <pre>\r73%\r\r74%\r\r75%\r\r76%\r\r77%\r</pre> <pre>\r78%\r\r79%\r\r80%\r\r81%\r\r82%\r</pre> <pre>\r83%\r\r84%\r\r85%\r\r86%\r\r87%\r</pre> <pre>\r88%\r\r89%\r\r90%\r\r91%\r\r92%\r</pre> <pre>\r93%\r\r94%\r\r95%\r\r96%\r\r97%\r</pre> <pre>\r98%\r\r99%\r\r100%\r</pre> <p>We need to select an efficient solver for this problem. For such a problem in TOUGH3 (3.0.0) GMRES with additive schwarz preconditioning from PETSc</p> <pre><code>-ksp_type gmres\n-pc_type asm\n-sub_pc_type lu\n-ksp_rtol 1e-8\n</code></pre> <p>or GMRES with ILU preconditioning from PETSc may be a good  choice:</p> <pre><code>-ksp_type gmres\n-ksp_gmres_restart 30\n-ksp_rtol 1e-8\n-pc_type ilu\n-pc_factor_mat_ordering_type natural\n-pc_factor_reuse_factorization\n-pc_factor_reuse_fill\n-pc_factor_reuse_ordering\n</code></pre> <p>After the simulation, we can attach the results from TOUGH3 to the vtu mesh using <code>outfile2vtu()</code> from  <code>voromesh.tough3</code>. Open the generated pvd file in Paraview to see results with timestamps.</p>"},{"location":"tough2/#mesh-properties-for-tough3-part-2","title":"Mesh properties for TOUGH3 (Part 2)\u00b6","text":""},{"location":"xymesh/","title":"Xymesh","text":"In\u00a0[1]: Copied! <pre>\"\"\"\nCreated on Wed Nov  8 14:28:49 2023\n\n@author: jante\n\"\"\"\n</pre> \"\"\" Created on Wed Nov  8 14:28:49 2023  @author: jante \"\"\" Out[1]: <pre>'\\nCreated on Wed Nov  8 14:28:49 2023\\n\\n@author: jante\\n'</pre> In\u00a0[2]: Copied! <pre>import numpy as np\n</pre> import numpy as np <p>def streamline(x): z = x/1000 return 200*np.tanh(z)+1.0</p> In\u00a0[3]: Copied! <pre>def streamline(x):\n    return 500*np.cos(x/2000)+1.0\n</pre> def streamline(x):     return 500*np.cos(x/2000)+1.0 In\u00a0[4]: Copied! <pre>def xymesh(xmin=-6000, xmax=6000, dx=20, dy=2, layer=39):\n\n    x = list()\n    y = list()\n\n    x0 = xmin\n    y0 = streamline(x0)\n\n    x.append(x0)\n    y.append(y0)\n\n    while x0 &lt; xmax:\n\n        x1_guess = x0 + dx\n        y1_guess = streamline(x1_guess)\n\n        d_guess = dx - np.sqrt((x0-x1_guess)**2 + (y0-y1_guess)**2)\n\n        x1 = x1_guess - d_guess/dx * (x1_guess-x0)\n        y1 = streamline(x1)\n\n        x.append(x1)\n        y.append(y1)\n\n        x0 = x1\n        y0 = y1\n\n    x = np.array(x)\n    y = np.array(y)\n\n    xx = x.copy()\n    yy = y.copy()\n\n    for j in range(layer):\n        xneu = list()\n        yneu = list()\n\n        xneu.append(x[0])\n        yneu.append(y[0]+dy)\n\n        for i in range(len(x)-1):\n\n            n1 = x[i+1]-x[i]\n            n2 = y[i+1]-y[i]\n\n            d_guess = np.sqrt(n1**2 + n2**2)\n\n            xneu.append(x[i+1] - dy/d_guess * n2)\n            yneu.append(y[i+1] + dy/d_guess * n1)\n\n        xx = np.hstack((xx, xneu))\n        yy = np.hstack((yy, yneu))\n\n        x = xneu\n        y = yneu\n\n    return np.column_stack((xx, yy))\n</pre> def xymesh(xmin=-6000, xmax=6000, dx=20, dy=2, layer=39):      x = list()     y = list()      x0 = xmin     y0 = streamline(x0)      x.append(x0)     y.append(y0)      while x0 &lt; xmax:          x1_guess = x0 + dx         y1_guess = streamline(x1_guess)          d_guess = dx - np.sqrt((x0-x1_guess)**2 + (y0-y1_guess)**2)          x1 = x1_guess - d_guess/dx * (x1_guess-x0)         y1 = streamline(x1)          x.append(x1)         y.append(y1)          x0 = x1         y0 = y1      x = np.array(x)     y = np.array(y)      xx = x.copy()     yy = y.copy()      for j in range(layer):         xneu = list()         yneu = list()          xneu.append(x[0])         yneu.append(y[0]+dy)          for i in range(len(x)-1):              n1 = x[i+1]-x[i]             n2 = y[i+1]-y[i]              d_guess = np.sqrt(n1**2 + n2**2)              xneu.append(x[i+1] - dy/d_guess * n2)             yneu.append(y[i+1] + dy/d_guess * n1)          xx = np.hstack((xx, xneu))         yy = np.hstack((yy, yneu))          x = xneu         y = yneu      return np.column_stack((xx, yy))"}]}